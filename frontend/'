import Point from "../types/point";
import Vector from "../types/vector";
import * as math from "mathjs";

export class MathModule {

  public static isValueInThreshold(currentValue: number, expectedValue: number, threshhold: number): boolean {
    const distance = Math.abs(currentValue - expectedValue);
    return distance <= threshhold;
  }

  public static normalizeRadAngleToDegrees(angle: number): number {
    let normalizedAngle = angle % (2 * Math.PI);

    if (normalizedAngle < 0) {
      normalizedAngle += 2 * Math.PI;
    }

    // We need to flip on the horizontal axis the angle
    return (360 - Phaser.Math.RadToDeg(normalizedAngle)) % 360;
  }

  public static scaledDistanceBetween(x1: number, y1: number, x2: number, y2: number): number {
    // We need to multiply the y distance by 2 because the y axis is scaled by 0.5
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow((y2 - y1) * 2, 2));
  }

  public static distanceBetween(x1: number, y1: number, x2: number, y2: number) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }

  public static getRandomPointInCircle(parentX: number, parentY: number, radius: number): Point {
    let point: Point = { x: parentX, y: parentY };
    const randomAngle_rad = Math.random() * 2 * Math.PI;
    const randomRadius = Math.random() * radius;

    point.x += randomRadius * Math.cos(randomAngle_rad);
    point.y += randomRadius * Math.sin(randomAngle_rad);
    return point;
  }

  public static getVectorLinearComposition(vx: number, vy: number, v1x: number, v1y: number, v2x: number, v2y: number) {
    const m = math.matrix([[v1x, v2x], [v1y, v2y]]);
    const x = math.lusolve(m, [vx, vy]);
    console.log(x);
    console.log(x.get(0));
    // return [new Vector(v1x * x[0][0], v1y * x[0][0]), new Vector(v2x * x[1][0], v2y * x[1][0])];
  }
}
